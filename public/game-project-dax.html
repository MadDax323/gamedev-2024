<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Improved Roguelike Game</title>
    <style>
        body {
            font-family: monospace;
            background-color: #000;
            color: #0f0;
            margin: 0;
            padding: 10px;
        }

        #game {
            white-space: pre;
            font-size: 14px;
            overflow: auto;
            max-height: 70vh;
            border: 1px solid #0f0;
            padding: 10px;
        }

        #inventory {
            margin-top: 10px;
            border: 1px solid #0f0;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .slot {
            border: 1px solid #0f0;
            padding: 5px;
            text-align: center;
            flex: 1 0 120px;
            background-color: rgba(0, 0, 0, 0.9);
            color: #0f0;
        }

        .slot.equipped {
            background-color: #00ff00;
            color: #000;
        }

        #message {
            margin-top: 10px;
            color: #ff0;
        }
    </style>
</head>
<body>
    <h1>Improved Roguelike Game</h1>
    <div id="game"></div>
    <div id="inventory"></div>
    <div id="message"></div>

    <script>
        // Game configuration
        const MAP_WIDTH = 80;
        const MAP_HEIGHT = 40;
        const PLAYER_SYMBOL = '@';
        const WALL_SYMBOL = '#';
        const FLOOR_SYMBOL = '.';
        const ENEMY_SYMBOL = 'E';
        const EXIT_SYMBOL = 'X';
        const CHEST_SYMBOL = 'C';

        let gameMap = [];
        let rooms = [];
        let playerPos = { x: 0, y: 0 };
        let enemies = [];
        let inventory = [];
        let equippedItem = null;
        let gameMessage = "";

        // Room class
        class Room {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }

            center() {
                return {
                    x: Math.floor(this.x + this.width / 2),
                    y: Math.floor(this.y + this.height / 2)
                };
            }

            intersects(other) {
                return (
                    this.x < other.x + other.width &&
                    this.x + this.width > other.x &&
                    this.y < other.y + other.height &&
                    this.y + this.height > other.y
                );
            }
        }

        // Procedural map generation
        function generateMap() {
            gameMap = Array.from({ length: MAP_HEIGHT }, () =>
                Array.from({ length: MAP_WIDTH }, () => WALL_SYMBOL)
            );

            const MAX_ROOMS = 10;
            const MIN_ROOM_SIZE = 6;
            const MAX_ROOM_SIZE = 12;

            for (let i = 0; i < MAX_ROOMS; i++) {
                const width = Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1)) + MIN_ROOM_SIZE;
                const height = Math.floor(Math.random() * (MAX_ROOM_SIZE - MIN_ROOM_SIZE + 1)) + MIN_ROOM_SIZE;
                const x = Math.floor(Math.random() * (MAP_WIDTH - width - 1)) + 1;
                const y = Math.floor(Math.random() * (MAP_HEIGHT - height - 1)) + 1;

                const newRoom = new Room(x, y, width, height);

                if (!rooms.some(room => room.intersects(newRoom))) {
                    rooms.push(newRoom);

                    for (let row = y; row < y + height; row++) {
                        for (let col = x; col < x + width; col++) {
                            gameMap[row][col] = FLOOR_SYMBOL;
                        }
                    }

                    // Connect rooms
                    if (rooms.length > 1) {
                        const prevRoom = rooms[rooms.length - 2];
                        const { x: x1, y: y1 } = prevRoom.center();
                        const { x: x2, y: y2 } = newRoom.center();

                        if (Math.random() < 0.5) {
                            createHorizontalTunnel(x1, x2, y1);
                            createVerticalTunnel(y1, y2, x2);
                        } else {
                            createVerticalTunnel(y1, y2, x1);
                            createHorizontalTunnel(x1, x2, y2);
                        }
                    }
                }
            }

            // Place player in the first room
            const { x, y } = rooms[0].center();
            playerPos = { x, y };

            // Place exit in the last room
            const { x: exitX, y: exitY } = rooms[rooms.length - 1].center();
            gameMap[exitY][exitX] = EXIT_SYMBOL;
        }

        function createHorizontalTunnel(x1, x2, y) {
            for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                gameMap[y][x] = FLOOR_SYMBOL;
            }
        }

        function createVerticalTunnel(y1, y2, x) {
            for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                gameMap[y][x] = FLOOR_SYMBOL;
            }
        }

        function spawnEnemies(count) {
            enemies = [];
            for (let i = 0; i < count; i++) {
                const room = rooms[Math.floor(Math.random() * rooms.length)];
                const x = Math.floor(Math.random() * room.width) + room.x;
                const y = Math.floor(Math.random() * room.height) + room.y;
                enemies.push({ x, y, health: 20 });
                gameMap[y][x] = ENEMY_SYMBOL;
            }
        }

        function spawnChests(count) {
            for (let i = 0; i < count; i++) {
                const room = rooms[Math.floor(Math.random() * rooms.length)];
                const x = Math.floor(Math.random() * room.width) + room.x;
                const y = Math.floor(Math.random() * room.height) + room.y;
                gameMap[y][x] = CHEST_SYMBOL;
            }
        }

        function drawMap() {
            let output = '';
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (x === playerPos.x && y === playerPos.y) {
                        output += PLAYER_SYMBOL;
                    } else {
                        output += gameMap[y][x];
                    }
                }
                output += '\n';
            }
            document.getElementById('game').textContent = output;
            document.getElementById('message').textContent = gameMessage;
        }

        function movePlayer(dx, dy) {
            const newX = playerPos.x + dx;
            const newY = playerPos.y + dy;

            if (gameMap[newY][newX] === WALL_SYMBOL) return;

            const tile = gameMap[newY][newX];

            if (tile === EXIT_SYMBOL) {
                gameMessage = "You found the exit! Victory!";
                drawMap();
                return;
            }

            playerPos = { x: newX, y: newY };
            drawMap();
        }

        // Initialize the game
        generateMap();
        spawnEnemies(5);
        spawnChests(3);
        drawMap();

        window.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': movePlayer(0, -1); break;
                case 'ArrowDown': movePlayer(0, 1); break;
                case 'ArrowLeft': movePlayer(-1, 0); break;
                case 'ArrowRight': movePlayer(1, 0); break;
            }
        });
    </script>
</body>
</html>
