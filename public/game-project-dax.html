<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Roguelike Game</title>
    <style>
        body {
            font-family: monospace;
            background-color: #000;
            color: #0f0;
        }

        #game {
            white-space: pre;
            font-size: 16px;
            border: 1px solid #0f0;
            padding: 10px;
            line-height: 1.2;
        }

        #message {
            color: #FF0000;
            text-align: center;
        }
    </style>
</head>

<body>
    <h1>ASCII Roguelike Game</h1>
    <div id="game"></div>
    <div id="message"></div>

    <script>
        const width = 40; // Map width
        const height = 20; // Map height
        const playerSymbol = '@';
        const wallSymbol = '#';
        const floorSymbol = '.';
        const exitSymbol = 'E';
        const unexploredSymbol = ' ';

        let playerPos = { x: 0, y: 0 };
        let gameMap = [];
        let visibilityMap = [];
        let currentLevel = 0; // Track the number of generated maps
        const maxRooms = 10; // Increase the number of rooms per map
        const roomMinSize = 3;
        const roomMaxSize = 6;

        function initializeMap() {
            gameMap = [];
            for (let y = 0; y < height; y++) {
                let row = '';
                for (let x = 0; x < width; x++) {
                    row += wallSymbol; // Start with walls
                }
                gameMap.push(row);
            }
            initializeVisibility();
        }

        function initializeVisibility() {
            visibilityMap = [];
            for (let y = 0; y < height; y++) {
                let row = '';
                for (let x = 0; x < width; x++) {
                    row += unexploredSymbol; // Initialize all as unexplored
                }
                visibilityMap.push(row);
            }
            visibilityMap[playerPos.y] = visibilityMap[playerPos.y].substring(0, playerPos.x) + floorSymbol.repeat(width - playerPos.x);
        }

        function createRoom(x, y, roomWidth, roomHeight) {
            for (let i = x; i < x + roomWidth; i++) {
                for (let j = y; j < y + roomHeight; j++) {
                    gameMap[j] = gameMap[j].substring(0, i) + floorSymbol + gameMap[j].substring(i + 1);
                }
            }
        }

        function connectRooms(room1, room2) {
            const x1 = room1.x + Math.floor(room1.width / 2);
            const y1 = room1.y + Math.floor(room1.height / 2);
            const x2 = room2.x + Math.floor(room2.width / 2);
            const y2 = room2.y + Math.floor(room2.height / 2);

            // Draw a hallway between the two rooms
            if (Math.random() < 0.5) {
                drawHorizontalHallway(x1, x2, y1);
                drawVerticalHallway(y1, y2, x2);
            } else {
                drawVerticalHallway(y1, y2, x1);
                drawHorizontalHallway(x1, x2, y2);
            }
        }

        function drawHorizontalHallway(x1, x2, y) {
            for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                gameMap[y] = gameMap[y].substring(0, x) + floorSymbol + gameMap[y].substring(x + 1);
            }
        }

        function drawVerticalHallway(y1, y2, x) {
            for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                gameMap[y] = gameMap[y].substring(0, x) + floorSymbol + gameMap[y].substring(x + 1);
            }
        }

        function generateRandomMap() {
            initializeMap();
            const rooms = [];

            while (rooms.length < maxRooms) {
                const roomWidth = Math.floor(Math.random() * (roomMaxSize - roomMinSize + 1)) + roomMinSize;
                const roomHeight = Math.floor(Math.random() * (roomMaxSize - roomMinSize + 1)) + roomMinSize;
                const x = Math.floor(Math.random() * (width - roomWidth - 1)) + 1; // Exclude walls
                const y = Math.floor(Math.random() * (height - roomHeight - 1)) + 1; // Exclude walls

                const newRoom = { x, y, width: roomWidth, height: roomHeight };

                // Check for overlaps with other rooms
                let overlap = rooms.some(otherRoom =>
                    x < otherRoom.x + otherRoom.width &&
                    x + roomWidth > otherRoom.x &&
                    y < otherRoom.y + otherRoom.height &&
                    y + roomHeight > otherRoom.y
                );

                if (!overlap) {
                    createRoom(x, y, roomWidth, roomHeight);
                    rooms.push(newRoom);
                    // Connect to the previous room if it exists
                    if (rooms.length > 1) {
                        connectRooms(rooms[rooms.length - 2], newRoom);
                    }
                }
            }

            // Place an exit in the last room created
            const lastRoom = rooms[rooms.length - 1];
            const exitX = lastRoom.x + Math.floor(lastRoom.width / 2);
            const exitY = lastRoom.y + Math.floor(lastRoom.height / 2);
            gameMap[exitY] = gameMap[exitY].substring(0, exitX) + exitSymbol + gameMap[exitY].substring(exitX + 1);

            // Ensure the player's starting position is within a floor tile
            playerPos.x = Math.floor(width / 2);
            playerPos.y = Math.floor(height / 2);
            gameMap[playerPos.y] = gameMap[playerPos.y].substring(0, playerPos.x) + floorSymbol + gameMap[playerPos.y].substring(playerPos.x + 1);
        }

        function draw() {
            let output = '';
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (x === playerPos.x && y === playerPos.y) {
                        output += playerSymbol; // Player
                    } else if (visibilityMap[y][x] !== unexploredSymbol) {
                        output += gameMap[y][x]; // Revealed map
                    } else {
                        output += unexploredSymbol; // Fog of war
                    }
                }
                output += '\n';
            }
            document.getElementById('game').textContent = output;
        }

        function movePlayer(dx, dy) {
            const newX = playerPos.x + dx;
            const newY = playerPos.y + dy;

            // Check for wall or exit
            if (gameMap[newY][newX] !== wallSymbol) {
                if (gameMap[newY][newX] === exitSymbol) {
                    currentLevel++;
                    if (currentLevel < 5) {
                        generateRandomMap();
                    } else {
                        // Transition to boss arena
                        document.getElementById('message').textContent = "You have entered the boss arena!";
                        generateBossArena();
                    }
                } else {
                    playerPos.x = newX;
                    playerPos.y = newY;

                    // Update the visibility map
                    revealSurroundings();
                    draw();
                }
            }
        }

        function revealSurroundings() {
            const revealDistance = 2; // How far the player can see
            for (let dy = -revealDistance; dy <= revealDistance; dy++) {
                for (let dx = -revealDistance; dx <= revealDistance; dx++) {
                    const checkX = playerPos.x + dx;
                    const checkY = playerPos.y + dy;
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        visibilityMap[checkY] = visibilityMap[checkY].substring(0, checkX) + gameMap[checkY][checkX] + visibilityMap[checkY].substring(checkX + 1);
                    }
                }
            }
        }

        function generateBossArena() {
            // Create a 10x10 arena
            const arenaWidth = 10;
            const arenaHeight = 10;
            let arenaMap = Array(arenaHeight).fill('#'.repeat(arenaWidth));

            // Center the player in the arena
            playerPos.x = Math.floor(arenaWidth / 2);
            playerPos.y = Math.floor(arenaHeight / 2);
            arenaMap[playerPos.y] = arenaMap[playerPos.y].substring(0, playerPos.x) + floorSymbol + arenaMap[playerPos.y].substring(playerPos.x + 1);

            // Update the game map and draw the boss arena
            gameMap = arenaMap;
            revealSurroundings();
            draw();
        }

        window.addEventListener("keydown", (e) => {
            switch (e.key) {
                case "ArrowUp":
                    movePlayer(0, -1);
                    break;
                case "ArrowDown":
                    movePlayer(0, 1);
                    break;
                case "ArrowLeft":
                    movePlayer(-1, 0);
                    break;
                case "ArrowRight":
                    movePlayer(1, 0);
                    break;
            }
        });

        // Initialize the game
        generateRandomMap();
        initializeVisibility();
        draw();
    </script>
</body>

</html>
